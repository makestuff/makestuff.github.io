<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>

<title>libfpgalink.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<!-- Generated by Doxygen 1.7.5.1 -->
</div>
<div class="header">
  <div class="headertitle">
<div class="title">libfpgalink.h File Reference</div>  </div>
</div>
<div class="contents">

<p><a href="libfpgalink_8h_source.html">Go to the source code of this file.</a></p>
<div class="textblock"><p>The <b>FPGALink</b> library makes it easier to talk to an FPGA over USB (via a suitable micro).</p>
<p>It performs three classes of function:</p>
<ul>
<li>Load device firmware and EEPROM (specific to Cypress FX2LP).</li>
<li>Program an FPGA or CPLD using JTAG or one of the proprietary serial or parallel algorithms.</li>
<li>Read and write (over USB) up to 128 byte-wide data channels in the target FPGA.</li>
<li>Manipulate microcontroller digital I/O and SPI port(s). </li>
</ul>
</div>
<hr/><h2>Overview</h2>
<table class="memberdecls">
<tr><td colspan="2"><div class="groupHeader">Types</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> { <br/>
&#160;&#160;<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271afc48adecd0c5aa0e3aa6e06fb87eb41f">FL_SUCCESS</a> =  0, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271af19fc66bfd9dfdbc5e1684b3cdef5a47">FL_ALLOC_ERR</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271acf7f011782c56aa962640f106c893890">FL_USB_ERR</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a8841aeb960a2ea8b26c3de3d45e99567">FL_PROTOCOL_ERR</a>, 
<br/>
&#160;&#160;<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a6b44afea4399f886e1cad0fece19fff4">FL_EARLY_TERM</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a2a304cc19708593a51615cd811c62b7e">FL_FX2_ERR</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a69ccba38c05c5aa6fe3ea20da5032212">FL_FILE_ERR</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a8e6be19e0f1e78d2b4f7093bf6586c79">FL_UNSUPPORTED_CMD_ERR</a>, 
<br/>
&#160;&#160;<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a905ceb6b6f6f4b28148503abd1c39bef">FL_UNSUPPORTED_DATA_ERR</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271afcf5a8c7eb9f93672e03743cd5f9b3ff">FL_UNSUPPORTED_SIZE_ERR</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271ace80539385caa913b8099e5ad1b67a38">FL_SVF_PARSE_ERR</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271ae5654f831751fa10da8e25af111767b4">FL_CONF_FORMAT</a>, 
<br/>
&#160;&#160;<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a7b2053ca9a09aaca9fbad2360c083273">FL_PROG_PORT_MAP</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a6821c3ed19fc393c21489b4e3d752d54">FL_PROG_SEND</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a1d3055d3659ac91a2260867d5002bbb6">FL_PROG_RECV</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a34891cbffab44f7e72bfa0a7dbebee45">FL_PROG_SHIFT</a>, 
<br/>
&#160;&#160;<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a14ae6712780b44eeb78674cd40dbddb5">FL_PROG_JTAG_FSM</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a36b5137410383e527bd13cc38938f66f">FL_PROG_JTAG_CLOCKS</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a62cf40b0458b4210c3caa15247243828">FL_PROG_SVF_COMPARE</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a352aac241198968da7c6b00a5c5ba30f">FL_PROG_SVF_UNKNOWN_CMD</a>, 
<br/>
&#160;&#160;<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a9b3ae05ce729c1479939dc5e4d1db4c2">FL_PROG_ERR</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a040a62398ba439dc5b423e0c14960bf7">FL_PORT_IO</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a1fe4335fa07649396615d17bfa7497e9">FL_BAD_STATE</a>, 
<a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271a0126f173d0248971a14dc2a9ea7784d0">FL_INTERNAL_ERR</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8">LogicalPort</a> { <br/>
&#160;&#160;<a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8a7174e60bb9fcc2cb5d29bff161a42079">LP_CHOOSE</a>, 
<a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8a899874ac88fd825ab75c5142da674c9a">LP_MISO</a>, 
<a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8a5848d30a472686aa23863e51da43538c">LP_MOSI</a>, 
<a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8a57d64ab9ceb78d1bf8197ee6da994214">LP_SS</a>, 
<br/>
&#160;&#160;<a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8ad6438ad57a046c4d4785917d06130f85">LP_SCK</a>, 
<a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8a3a34f4255a997ba96b915a518c1b460a">LP_D8</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a3a8a28825ae2b26e757181838cf38a8f">PinConfig</a> { <a class="el" href="libfpgalink_8h.html#a3a8a28825ae2b26e757181838cf38a8fa18cf6cd3410235585c7a774ee14571e2">PIN_UNUSED</a>, 
<a class="el" href="libfpgalink_8h.html#a3a8a28825ae2b26e757181838cf38a8fa75e7ef64e7e3e078a6d2a7cc2d790226">PIN_HIGH</a>, 
<a class="el" href="libfpgalink_8h.html#a3a8a28825ae2b26e757181838cf38a8faf6ea07d163784d7bef21d4c12fa77ec7">PIN_LOW</a>, 
<a class="el" href="libfpgalink_8h.html#a3a8a28825ae2b26e757181838cf38a8fa9473a73f5d4f521d8dd4459d84a5e580">PIN_INPUT</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a045d07d899642c93c7e9d9f2b23af156">BitOrder</a> { <a class="el" href="libfpgalink_8h.html#a045d07d899642c93c7e9d9f2b23af156a3fa35f661bf7fbb96c05ff70827553be">SPI_MSBFIRST</a>, 
<a class="el" href="libfpgalink_8h.html#a045d07d899642c93c7e9d9f2b23af156a183d076e845f5ea5d99465cd6aff505f">SPI_LSBFIRST</a>
 }</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Functions</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a973de7f601138a3e3bb8f6e184ee9be8">flInitialise</a> (int debugLevel, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the library with the given log level.  <a href="#a973de7f601138a3e3bb8f6e184ee9be8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b">flFreeError</a> (const char *err)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an error allocated when one of the other functions fails.  <a href="#a313f24c559a56d12518cb1e7eacdf01b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Connection Lifecycle</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424">flOpen</a> (const char *vp, struct FLContext **handle, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a connection to the FPGALink device at the specified VID and PID.  <a href="#a241ac59f7ba96caba2e1262ffd0d4424"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#aec8a71aea72766e3c57fa857c5f5f742">flClose</a> (struct FLContext *handle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an existing connection to an FPGALink device.  <a href="#aec8a71aea72766e3c57fa857c5f5f742"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Device Capabilities and Status</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#ae188886270ebadecace4ff6d9f3086d4">flIsDeviceAvailable</a> (const char *vp, uint8 *isAvailable, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given device is actually connected to the system.  <a href="#ae188886270ebadecace4ff6d9f3086d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#abe1ca39675be0542bec2b4382814c5ff">flIsNeroCapable</a> (struct FLContext *handle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the device supports NeroProg.  <a href="#abe1ca39675be0542bec2b4382814c5ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a9fc3d09dd96583c9219c1a0343aecbf1">flIsCommCapable</a> (struct FLContext *handle, uint8 conduit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the device supports CommFPGA.  <a href="#a9fc3d09dd96583c9219c1a0343aecbf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#ac537f96c6d8b117391b5233f70bf0cba">flGetFirmwareID</a> (struct FLContext *handle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the firmware ID.  <a href="#ac537f96c6d8b117391b5233f70bf0cba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#ac07c92e2752b9280496d32c8e9ff5df5">flGetFirmwareVersion</a> (struct FLContext *handle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the firmware version.  <a href="#ac07c92e2752b9280496d32c8e9ff5df5"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">CommFPGA Operations</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#ae33aab1191c1f69a48152a186b239575">flSelectConduit</a> (struct FLContext *handle, uint8 conduit, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a different conduit.  <a href="#ae33aab1191c1f69a48152a186b239575"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a2afc988a5fa70e4c273fe60595d61799">flIsFPGARunning</a> (struct FLContext *handle, uint8 *isRunning, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the FPGA is running.  <a href="#a2afc988a5fa70e4c273fe60595d61799"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a16b33b61b48b288f370b7b4483e5816f">flReadChannel</a> (struct FLContext *handle, uint8 channel, size_t numBytes, uint8 *buffer, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read one or more bytes from the specified channel.  <a href="#a16b33b61b48b288f370b7b4483e5816f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a24aeb007ae3a83ca2a5d745c023beadd">flWriteChannel</a> (struct FLContext *handle, uint8 channel, size_t numBytes, const uint8 *sendData, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write one or more bytes to the specified channel.  <a href="#a24aeb007ae3a83ca2a5d745c023beadd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#acd7c2694cbafa6df84c3b9f9fa5a1109">flSetAsyncWriteChunkSize</a> (struct FLContext *handle, uint16 chunkSize, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the chunk size to be used for future async writes.  <a href="#acd7c2694cbafa6df84c3b9f9fa5a1109"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a4f497ab3ea733a6dc679c23c83b7a13a">flWriteChannelAsync</a> (struct FLContext *handle, uint8 channel, size_t numBytes, const uint8 *sendData, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously write one or more bytes to the specified channel.  <a href="#a4f497ab3ea733a6dc679c23c83b7a13a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#ae4a0003f5fcf0e483f5373c95cce6438">flFlushAsyncWrites</a> (struct FLContext *handle, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush out any pending asynchronous writes.  <a href="#ae4a0003f5fcf0e483f5373c95cce6438"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a0f7c12381f2353ea1741747051996940">flAwaitAsyncWrites</a> (struct FLContext *handle, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for confirmation that pending asynchronous writes were received by the micro.  <a href="#a0f7c12381f2353ea1741747051996940"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a4513434ff0d3d57d951f6b25189938b0">flReadChannelAsyncSubmit</a> (struct FLContext *handle, uint8 channel, uint32 numBytes, uint8 *buffer, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an asynchronous read of one or more bytes from the specified channel.  <a href="#a4513434ff0d3d57d951f6b25189938b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a80ec3f7e30e605c744d2a631c73110bb">flReadChannelAsyncAwait</a> (struct FLContext *handle, const uint8 **recvData, uint32 *requestLength, uint32 *actualLength, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Await the data from a previously-submitted asynchronous read.  <a href="#a80ec3f7e30e605c744d2a631c73110bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a7fbc8058cc9c3afe924357be1836bc3c">flResetToggle</a> (struct FLContext *handle, const char **error)</td></tr>
<tr><td colspan="2"><div class="groupHeader">NeroProg Operations</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#aee1237800fd15040940c9a288fef4c40">flProgram</a> (struct FLContext *handle, const char *progConfig, const char *progFile, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Program a device using the specified file.  <a href="#aee1237800fd15040940c9a288fef4c40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#af2e29b8b5a6a6d8ec1e453cdb4682466">flProgramBlob</a> (struct FLContext *handle, const char *progConfig, uint32 numBytes, const uint8 *progData, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Program a device using the specified programming blob.  <a href="#af2e29b8b5a6a6d8ec1e453cdb4682466"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a54789a8a9da4ab5f9c6b7265cac80c6d">jtagScanChain</a> (struct FLContext *handle, const char *portConfig, uint32 *numDevices, uint32 *deviceArray, uint32 arraySize, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan the JTAG chain and return an array of IDCODEs.  <a href="#a54789a8a9da4ab5f9c6b7265cac80c6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a1d42bc3e63b9cea034add652e1e11df5">progOpen</a> (struct FLContext *handle, const char *portConfig, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an SPI/JTAG connection.  <a href="#a1d42bc3e63b9cea034add652e1e11df5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a52e3a1c5303e9b0bee6c749561e0c22f">progClose</a> (struct FLContext *handle, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an SPI/JTAG connection.  <a href="#a52e3a1c5303e9b0bee6c749561e0c22f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a3c24aed4dc6604a169b99ef9e73caa69">jtagShiftInOnly</a> (struct FLContext *handle, uint32 numBits, const uint8 *tdiData, uint8 isLast, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift data into the JTAG state-machine.  <a href="#a3c24aed4dc6604a169b99ef9e73caa69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#abeabe9c6b30bee45a71560e5252d3d64">jtagShiftInOut</a> (struct FLContext *handle, uint32 numBits, const uint8 *tdiData, uint8 *tdoData, uint8 isLast, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift data into and out of the JTAG state-machine.  <a href="#abeabe9c6b30bee45a71560e5252d3d64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a618f685e40c8688ae202eae4d78649e3">jtagClockFSM</a> (struct FLContext *handle, uint32 bitPattern, uint8 transitionCount, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock <code>transitionCount</code> bits from <code>bitPattern</code> into TMS, starting with the LSB.  <a href="#a618f685e40c8688ae202eae4d78649e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#aff511cfdba78e8943282a0d29acfd42b">jtagClocks</a> (struct FLContext *handle, uint32 numClocks, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle TCK <code>numClocks</code> times.  <a href="#aff511cfdba78e8943282a0d29acfd42b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#aae2d0358833df24c04350cf804c63d22">progGetPort</a> (struct FLContext *handle, uint8 logicalPort)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical port number of the specified logical port.  <a href="#aae2d0358833df24c04350cf804c63d22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#aca840e749e80dc01fada76fb151cd8b5">progGetBit</a> (struct FLContext *handle, uint8 logicalPort)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical bit number of the specified logical port.  <a href="#aca840e749e80dc01fada76fb151cd8b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#ad5df0a1ae846da4860083fdbe27e6c04">spiSend</a> (struct FLContext *handle, uint32 numBytes, const uint8 *sendData, uint8 bitOrder, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a number of whole bytes over SPI, either LSB-first or MSB-first.  <a href="#ad5df0a1ae846da4860083fdbe27e6c04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a414f5196eddbb5e79a7e2a85ebdfbe35">spiRecv</a> (struct FLContext *handle, uint32 numBytes, uint8 *buffer, uint8 bitOrder, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a number of whole bytes over SPI, either LSB-first or MSB-first.  <a href="#a414f5196eddbb5e79a7e2a85ebdfbe35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a7d1aecb85d5d4d07b180762458e15690">spiBitSwap</a> (uint32 numBytes, uint8 *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the bits in a byte array.  <a href="#a7d1aecb85d5d4d07b180762458e15690"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Firmware Operations</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#aaee82d54cdcf6476a545885127d8a952">flLoadStandardFirmware</a> (const char *curVidPid, const char *newVidPid, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load standard FPGALink firmware into the FX2's RAM.  <a href="#aaee82d54cdcf6476a545885127d8a952"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a193d503842ab1351cf1c6cf08c3764cd">flFlashStandardFirmware</a> (struct FLContext *handle, const char *newVidPid, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash standard FPGALink firmware into the FX2's EEPROM.  <a href="#a193d503842ab1351cf1c6cf08c3764cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#ae14ca5ab58b526815c80ca09793e5e34">flLoadCustomFirmware</a> (const char *curVidPid, const char *fwFile, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load custom firmware (<code>.hex</code>) into the FX2's RAM.  <a href="#ae14ca5ab58b526815c80ca09793e5e34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a1e67bed33586e784415791e5131e0b6b">flFlashCustomFirmware</a> (struct FLContext *handle, const char *fwFile, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash a custom firmware from a file into the FX2's EEPROM.  <a href="#a1e67bed33586e784415791e5131e0b6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#addfaedd80f0f40c9a1f134766235b23b">flSaveFirmware</a> (struct FLContext *handle, uint32 eepromSize, const char *saveFile, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save existing EEPROM data to a file.  <a href="#addfaedd80f0f40c9a1f134766235b23b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a839988198379a25e7a0eaad38e00deab">flBootloader</a> (struct FLContext *handle, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the AVR in DFU bootloader mode.  <a href="#a839988198379a25e7a0eaad38e00deab"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility Functions</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a58a48f47195b55d4921659a74d9eed5d">flSleep</a> (uint32 ms)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for the specified number of milliseconds.  <a href="#a58a48f47195b55d4921659a74d9eed5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a549aade3b9ba7def5ef66e1f6315d1c7">flLoadFile</a> (const char *name, size_t *numBytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a newly-allocated buffer with the specified file loaded into it.  <a href="#a549aade3b9ba7def5ef66e1f6315d1c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a17909597ec81d8610c791a1ebf5f1400">flFreeFile</a> (uint8 *buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a buffer previously returned by <code><a class="el" href="libfpgalink_8h.html#a549aade3b9ba7def5ef66e1f6315d1c7" title="Return a newly-allocated buffer with the specified file loaded into it.">flLoadFile()</a></code>.  <a href="#a17909597ec81d8610c791a1ebf5f1400"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#afd0ab7d13a50ef7b375f8baabb9d820a">flSingleBitPortAccess</a> (struct FLContext *handle, uint8 portNumber, uint8 bitNumber, uint8 pinConfig, uint8 *pinRead, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a single port bit on the microcontroller.  <a href="#afd0ab7d13a50ef7b375f8baabb9d820a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libfpgalink_8h.html#a0130b09f179fc14ab9be191ca3083432">flMultiBitPortAccess</a> (struct FLContext *handle, const char *portConfig, uint32 *readState, const char **error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure multiple port bits on the microcontroller.  <a href="#a0130b09f179fc14ab9be191ca3083432"></a><br/></td></tr>
</table>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a9dbd76495d70a6f62b70274c35348271"></a><!-- doxytag: member="libfpgalink.h::FLStatus" ref="a9dbd76495d70a6f62b70274c35348271" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return codes from the functions. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271afc48adecd0c5aa0e3aa6e06fb87eb41f"></a><!-- doxytag: member="FL_SUCCESS" ref="a9dbd76495d70a6f62b70274c35348271afc48adecd0c5aa0e3aa6e06fb87eb41f" args="" -->FL_SUCCESS</em>&nbsp;</td><td>
<p>The operation completed successfully. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271af19fc66bfd9dfdbc5e1684b3cdef5a47"></a><!-- doxytag: member="FL_ALLOC_ERR" ref="a9dbd76495d70a6f62b70274c35348271af19fc66bfd9dfdbc5e1684b3cdef5a47" args="" -->FL_ALLOC_ERR</em>&nbsp;</td><td>
<p>There was a memory allocation error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271acf7f011782c56aa962640f106c893890"></a><!-- doxytag: member="FL_USB_ERR" ref="a9dbd76495d70a6f62b70274c35348271acf7f011782c56aa962640f106c893890" args="" -->FL_USB_ERR</em>&nbsp;</td><td>
<p>There was some USB-related problem. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a8841aeb960a2ea8b26c3de3d45e99567"></a><!-- doxytag: member="FL_PROTOCOL_ERR" ref="a9dbd76495d70a6f62b70274c35348271a8841aeb960a2ea8b26c3de3d45e99567" args="" -->FL_PROTOCOL_ERR</em>&nbsp;</td><td>
<p>The device is probably not a valid FPGALink device. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a6b44afea4399f886e1cad0fece19fff4"></a><!-- doxytag: member="FL_EARLY_TERM" ref="a9dbd76495d70a6f62b70274c35348271a6b44afea4399f886e1cad0fece19fff4" args="" -->FL_EARLY_TERM</em>&nbsp;</td><td>
<p>The device did an unexpected early read termination. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a2a304cc19708593a51615cd811c62b7e"></a><!-- doxytag: member="FL_FX2_ERR" ref="a9dbd76495d70a6f62b70274c35348271a2a304cc19708593a51615cd811c62b7e" args="" -->FL_FX2_ERR</em>&nbsp;</td><td>
<p>There was some problem talking to the FX2 chip. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a69ccba38c05c5aa6fe3ea20da5032212"></a><!-- doxytag: member="FL_FILE_ERR" ref="a9dbd76495d70a6f62b70274c35348271a69ccba38c05c5aa6fe3ea20da5032212" args="" -->FL_FILE_ERR</em>&nbsp;</td><td>
<p>There was a file-related problem. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a8e6be19e0f1e78d2b4f7093bf6586c79"></a><!-- doxytag: member="FL_UNSUPPORTED_CMD_ERR" ref="a9dbd76495d70a6f62b70274c35348271a8e6be19e0f1e78d2b4f7093bf6586c79" args="" -->FL_UNSUPPORTED_CMD_ERR</em>&nbsp;</td><td>
<p>The XSVF file contains an unsupported command. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a905ceb6b6f6f4b28148503abd1c39bef"></a><!-- doxytag: member="FL_UNSUPPORTED_DATA_ERR" ref="a9dbd76495d70a6f62b70274c35348271a905ceb6b6f6f4b28148503abd1c39bef" args="" -->FL_UNSUPPORTED_DATA_ERR</em>&nbsp;</td><td>
<p>The XSVF file contains an unsupported XENDIR or XENDDR. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271afcf5a8c7eb9f93672e03743cd5f9b3ff"></a><!-- doxytag: member="FL_UNSUPPORTED_SIZE_ERR" ref="a9dbd76495d70a6f62b70274c35348271afcf5a8c7eb9f93672e03743cd5f9b3ff" args="" -->FL_UNSUPPORTED_SIZE_ERR</em>&nbsp;</td><td>
<p>The XSVF file requires more buffer space than is available. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271ace80539385caa913b8099e5ad1b67a38"></a><!-- doxytag: member="FL_SVF_PARSE_ERR" ref="a9dbd76495d70a6f62b70274c35348271ace80539385caa913b8099e5ad1b67a38" args="" -->FL_SVF_PARSE_ERR</em>&nbsp;</td><td>
<p>The SVF file is not parseable. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271ae5654f831751fa10da8e25af111767b4"></a><!-- doxytag: member="FL_CONF_FORMAT" ref="a9dbd76495d70a6f62b70274c35348271ae5654f831751fa10da8e25af111767b4" args="" -->FL_CONF_FORMAT</em>&nbsp;</td><td>
<p>The supplied programming config is malformed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a7b2053ca9a09aaca9fbad2360c083273"></a><!-- doxytag: member="FL_PROG_PORT_MAP" ref="a9dbd76495d70a6f62b70274c35348271a7b2053ca9a09aaca9fbad2360c083273" args="" -->FL_PROG_PORT_MAP</em>&nbsp;</td><td>
<p>There was a problem remapping ports for programming. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a6821c3ed19fc393c21489b4e3d752d54"></a><!-- doxytag: member="FL_PROG_SEND" ref="a9dbd76495d70a6f62b70274c35348271a6821c3ed19fc393c21489b4e3d752d54" args="" -->FL_PROG_SEND</em>&nbsp;</td><td>
<p>There was a problem sending data during programming. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a1d3055d3659ac91a2260867d5002bbb6"></a><!-- doxytag: member="FL_PROG_RECV" ref="a9dbd76495d70a6f62b70274c35348271a1d3055d3659ac91a2260867d5002bbb6" args="" -->FL_PROG_RECV</em>&nbsp;</td><td>
<p>There was a problem receiving data during programming. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a34891cbffab44f7e72bfa0a7dbebee45"></a><!-- doxytag: member="FL_PROG_SHIFT" ref="a9dbd76495d70a6f62b70274c35348271a34891cbffab44f7e72bfa0a7dbebee45" args="" -->FL_PROG_SHIFT</em>&nbsp;</td><td>
<p>There was a problem with the requested shift operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a14ae6712780b44eeb78674cd40dbddb5"></a><!-- doxytag: member="FL_PROG_JTAG_FSM" ref="a9dbd76495d70a6f62b70274c35348271a14ae6712780b44eeb78674cd40dbddb5" args="" -->FL_PROG_JTAG_FSM</em>&nbsp;</td><td>
<p>There was a problem navigating the JTAG state machine. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a36b5137410383e527bd13cc38938f66f"></a><!-- doxytag: member="FL_PROG_JTAG_CLOCKS" ref="a9dbd76495d70a6f62b70274c35348271a36b5137410383e527bd13cc38938f66f" args="" -->FL_PROG_JTAG_CLOCKS</em>&nbsp;</td><td>
<p>There was a problem issuing clocks during programming. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a62cf40b0458b4210c3caa15247243828"></a><!-- doxytag: member="FL_PROG_SVF_COMPARE" ref="a9dbd76495d70a6f62b70274c35348271a62cf40b0458b4210c3caa15247243828" args="" -->FL_PROG_SVF_COMPARE</em>&nbsp;</td><td>
<p>An SVF compare operation failed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a352aac241198968da7c6b00a5c5ba30f"></a><!-- doxytag: member="FL_PROG_SVF_UNKNOWN_CMD" ref="a9dbd76495d70a6f62b70274c35348271a352aac241198968da7c6b00a5c5ba30f" args="" -->FL_PROG_SVF_UNKNOWN_CMD</em>&nbsp;</td><td>
<p>An unknown SVF command was encountered. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a9b3ae05ce729c1479939dc5e4d1db4c2"></a><!-- doxytag: member="FL_PROG_ERR" ref="a9dbd76495d70a6f62b70274c35348271a9b3ae05ce729c1479939dc5e4d1db4c2" args="" -->FL_PROG_ERR</em>&nbsp;</td><td>
<p>The device failed to start after programming. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a040a62398ba439dc5b423e0c14960bf7"></a><!-- doxytag: member="FL_PORT_IO" ref="a9dbd76495d70a6f62b70274c35348271a040a62398ba439dc5b423e0c14960bf7" args="" -->FL_PORT_IO</em>&nbsp;</td><td>
<p>There was a problem doing port I/O. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a1fe4335fa07649396615d17bfa7497e9"></a><!-- doxytag: member="FL_BAD_STATE" ref="a9dbd76495d70a6f62b70274c35348271a1fe4335fa07649396615d17bfa7497e9" args="" -->FL_BAD_STATE</em>&nbsp;</td><td>
<p>You're trying to do something that is illegal in this state. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9dbd76495d70a6f62b70274c35348271a0126f173d0248971a14dc2a9ea7784d0"></a><!-- doxytag: member="FL_INTERNAL_ERR" ref="a9dbd76495d70a6f62b70274c35348271a0126f173d0248971a14dc2a9ea7784d0" args="" -->FL_INTERNAL_ERR</em>&nbsp;</td><td>
<p>An internal error occurred. Please report it! </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a507e3190734afde676318db508b389d8"></a><!-- doxytag: member="libfpgalink.h::LogicalPort" ref="a507e3190734afde676318db508b389d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8">LogicalPort</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum used by <code><a class="el" href="libfpgalink_8h.html#aae2d0358833df24c04350cf804c63d22" title="Get the physical port number of the specified logical port.">progGetPort()</a></code> and <code><a class="el" href="libfpgalink_8h.html#aca840e749e80dc01fada76fb151cd8b5" title="Get the physical bit number of the specified logical port.">progGetBit()</a></code> to identify the programming pins. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a507e3190734afde676318db508b389d8a7174e60bb9fcc2cb5d29bff161a42079"></a><!-- doxytag: member="LP_CHOOSE" ref="a507e3190734afde676318db508b389d8a7174e60bb9fcc2cb5d29bff161a42079" args="" -->LP_CHOOSE</em>&nbsp;</td><td>
<p>These aren't the droids you're looking for. Move along. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a507e3190734afde676318db508b389d8a899874ac88fd825ab75c5142da674c9a"></a><!-- doxytag: member="LP_MISO" ref="a507e3190734afde676318db508b389d8a899874ac88fd825ab75c5142da674c9a" args="" -->LP_MISO</em>&nbsp;</td><td>
<p>The master-in, slave-out pin (TDO). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a507e3190734afde676318db508b389d8a5848d30a472686aa23863e51da43538c"></a><!-- doxytag: member="LP_MOSI" ref="a507e3190734afde676318db508b389d8a5848d30a472686aa23863e51da43538c" args="" -->LP_MOSI</em>&nbsp;</td><td>
<p>The master-out, slave-in pin (TDI). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a507e3190734afde676318db508b389d8a57d64ab9ceb78d1bf8197ee6da994214"></a><!-- doxytag: member="LP_SS" ref="a507e3190734afde676318db508b389d8a57d64ab9ceb78d1bf8197ee6da994214" args="" -->LP_SS</em>&nbsp;</td><td>
<p>The slave-select pin (TMS). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a507e3190734afde676318db508b389d8ad6438ad57a046c4d4785917d06130f85"></a><!-- doxytag: member="LP_SCK" ref="a507e3190734afde676318db508b389d8ad6438ad57a046c4d4785917d06130f85" args="" -->LP_SCK</em>&nbsp;</td><td>
<p>The serial clock pin (TCK). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a507e3190734afde676318db508b389d8a3a34f4255a997ba96b915a518c1b460a"></a><!-- doxytag: member="LP_D8" ref="a507e3190734afde676318db508b389d8a3a34f4255a997ba96b915a518c1b460a" args="" -->LP_D8</em>&nbsp;</td><td>
<p>The parallel data port. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a8a28825ae2b26e757181838cf38a8f"></a><!-- doxytag: member="libfpgalink.h::PinConfig" ref="a3a8a28825ae2b26e757181838cf38a8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="libfpgalink_8h.html#a3a8a28825ae2b26e757181838cf38a8f">PinConfig</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum used by <code><a class="el" href="libfpgalink_8h.html#afd0ab7d13a50ef7b375f8baabb9d820a" title="Configure a single port bit on the microcontroller.">flSingleBitPortAccess()</a></code> to configure the pin direction and drive. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3a8a28825ae2b26e757181838cf38a8fa18cf6cd3410235585c7a774ee14571e2"></a><!-- doxytag: member="PIN_UNUSED" ref="a3a8a28825ae2b26e757181838cf38a8fa18cf6cd3410235585c7a774ee14571e2" args="" -->PIN_UNUSED</em>&nbsp;</td><td>
<p>These are also not the droids you're looking for. Keep moving along. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3a8a28825ae2b26e757181838cf38a8fa75e7ef64e7e3e078a6d2a7cc2d790226"></a><!-- doxytag: member="PIN_HIGH" ref="a3a8a28825ae2b26e757181838cf38a8fa75e7ef64e7e3e078a6d2a7cc2d790226" args="" -->PIN_HIGH</em>&nbsp;</td><td>
<p>Configure the pin as an output and drive it high. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3a8a28825ae2b26e757181838cf38a8faf6ea07d163784d7bef21d4c12fa77ec7"></a><!-- doxytag: member="PIN_LOW" ref="a3a8a28825ae2b26e757181838cf38a8faf6ea07d163784d7bef21d4c12fa77ec7" args="" -->PIN_LOW</em>&nbsp;</td><td>
<p>Configure the pin as an output and drive it low. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3a8a28825ae2b26e757181838cf38a8fa9473a73f5d4f521d8dd4459d84a5e580"></a><!-- doxytag: member="PIN_INPUT" ref="a3a8a28825ae2b26e757181838cf38a8fa9473a73f5d4f521d8dd4459d84a5e580" args="" -->PIN_INPUT</em>&nbsp;</td><td>
<p>Configure the pin as an input. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a045d07d899642c93c7e9d9f2b23af156"></a><!-- doxytag: member="libfpgalink.h::BitOrder" ref="a045d07d899642c93c7e9d9f2b23af156" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="libfpgalink_8h.html#a045d07d899642c93c7e9d9f2b23af156">BitOrder</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum used by <code><a class="el" href="libfpgalink_8h.html#ad5df0a1ae846da4860083fdbe27e6c04" title="Send a number of whole bytes over SPI, either LSB-first or MSB-first.">spiSend()</a></code> and <code><a class="el" href="libfpgalink_8h.html#a414f5196eddbb5e79a7e2a85ebdfbe35" title="Receive a number of whole bytes over SPI, either LSB-first or MSB-first.">spiRecv()</a></code> to set the order bits are clocked in. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a045d07d899642c93c7e9d9f2b23af156a3fa35f661bf7fbb96c05ff70827553be"></a><!-- doxytag: member="SPI_MSBFIRST" ref="a045d07d899642c93c7e9d9f2b23af156a3fa35f661bf7fbb96c05ff70827553be" args="" -->SPI_MSBFIRST</em>&nbsp;</td><td>
<p>Clock each byte most-significant bit first. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a045d07d899642c93c7e9d9f2b23af156a183d076e845f5ea5d99465cd6aff505f"></a><!-- doxytag: member="SPI_LSBFIRST" ref="a045d07d899642c93c7e9d9f2b23af156a183d076e845f5ea5d99465cd6aff505f" args="" -->SPI_LSBFIRST</em>&nbsp;</td><td>
<p>Clock each byte least-significant bit first. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a973de7f601138a3e3bb8f6e184ee9be8"></a><!-- doxytag: member="libfpgalink.h::flInitialise" ref="a973de7f601138a3e3bb8f6e184ee9be8" args="(int debugLevel, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flInitialise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>debugLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise the library with the given log level. </p>
<p>This may fail if LibUSB cannot talk to the USB host controllers through its kernel driver (e.g a Linux kernel with USB support disabled, or a machine lacking a USB host controller).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">debugLevel</td><td>0-&gt;none, 1, 2, 3-&gt;lots. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_USB_ERR</code> if there were problems initialising LibUSB. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a313f24c559a56d12518cb1e7eacdf01b"></a><!-- doxytag: member="libfpgalink.h::flFreeError" ref="a313f24c559a56d12518cb1e7eacdf01b" args="(const char *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flFreeError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free an error allocated when one of the other functions fails. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>An error message previously allocated by one of the other library functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a241ac59f7ba96caba2e1262ffd0d4424"></a><!-- doxytag: member="libfpgalink.h::flOpen" ref="a241ac59f7ba96caba2e1262ffd0d4424" args="(const char *vp, struct FLContext **handle, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flOpen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct FLContext **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a connection to the FPGALink device at the specified VID and PID. </p>
<p>Connects to the device and verifies it's an FPGALink device, then queries its capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vp</td><td>The Vendor/Product (i.e VVVV:PPPP) of the FPGALink device. You may also specify an optional device ID (e.g 1D50:602B:0004). If no device ID is supplied, it selects the first device with matching VID:PID. </td></tr>
    <tr><td class="paramname">handle</td><td>A pointer to a <code>struct FLContext*</code> which will be set on exit to point at a newly-allocated context structure. Responsibility for this allocated memory (and its associated USB resources) passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#aec8a71aea72766e3c57fa857c5f5f742" title="Close an existing connection to an FPGALink device.">flClose()</a></code>. Will be set <code>NULL</code> if an error occurs. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if all is well (<code>*handle</code> is valid).</li>
<li><code>FL_ALLOC_ERR</code> if there was a memory allocation failure.</li>
<li><code>FL_USB_ERR</code> if the VID:PID is invalid or the device cannot be found or opened.</li>
<li><code>FL_PROTOCOL_ERR</code> if the device is not an FPGALink device. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aec8a71aea72766e3c57fa857c5f5f742"></a><!-- doxytag: member="libfpgalink.h::flClose" ref="aec8a71aea72766e3c57fa857c5f5f742" args="(struct FLContext *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flClose </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close an existing connection to an FPGALink device. </p>
<p>If the handle is <code>NULL</code>, this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>, or <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae188886270ebadecace4ff6d9f3086d4"></a><!-- doxytag: member="libfpgalink.h::flIsDeviceAvailable" ref="ae188886270ebadecace4ff6d9f3086d4" args="(const char *vp, uint8 *isAvailable, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flIsDeviceAvailable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>isAvailable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the given device is actually connected to the system. </p>
<p>The LibUSB devices in the system are searched for a device with the given VID:PID.</p>
<p>There is a short period of time following a call to <code><a class="el" href="libfpgalink_8h.html#aaee82d54cdcf6476a545885127d8a952" title="Load standard FPGALink firmware into the FX2&#39;s RAM.">flLoadStandardFirmware()</a></code> or <code><a class="el" href="libfpgalink_8h.html#ae14ca5ab58b526815c80ca09793e5e34" title="Load custom firmware (.hex) into the FX2&#39;s RAM.">flLoadCustomFirmware()</a></code> during which this function will still return with <code>*isAvailable == 1</code> for the "current" VID:PID, so when you load new firmware, it's important to either wait a while before calling this function, or alternatively just ensure that the "new" VID:PID is different from the "current" VID:PID to avoid such false positives.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vp</td><td>The Vendor/Product (i.e VVVV:PPPP) of the FPGALink device. You may also specify an optional device ID (e.g 1D50:602B:0004). If no device ID is supplied, it selects the first device with matching VID:PID. </td></tr>
    <tr><td class="paramname">isAvailable</td><td>A pointer to an 8-bit integer which will be set on exit to 1 if available else 0. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if all is well (<code>*isAvailable</code> is valid).</li>
<li><code>FL_USB_ERR</code> if the VID:PID is invalid or if no USB buses were found (did you remember to call <code><a class="el" href="libfpgalink_8h.html#a973de7f601138a3e3bb8f6e184ee9be8" title="Initialise the library with the given log level.">flInitialise()</a></code>?). </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abe1ca39675be0542bec2b4382814c5ff"></a><!-- doxytag: member="libfpgalink.h::flIsNeroCapable" ref="abe1ca39675be0542bec2b4382814c5ff" args="(struct FLContext *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 flIsNeroCapable </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check to see if the device supports NeroProg. </p>
<p>NeroProg is the collective name for all the various programming algorithms supported by FPGALink, including but not limited to JTAG. An affirmative response means you are free to call <code><a class="el" href="libfpgalink_8h.html#aee1237800fd15040940c9a288fef4c40" title="Program a device using the specified file.">flProgram()</a></code>, <code><a class="el" href="libfpgalink_8h.html#af2e29b8b5a6a6d8ec1e453cdb4682466" title="Program a device using the specified programming blob.">flProgramBlob()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a54789a8a9da4ab5f9c6b7265cac80c6d" title="Scan the JTAG chain and return an array of IDCODEs.">jtagScanChain()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a1d42bc3e63b9cea034add652e1e11df5" title="Open an SPI/JTAG connection.">progOpen()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a52e3a1c5303e9b0bee6c749561e0c22f" title="Close an SPI/JTAG connection.">progClose()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a3c24aed4dc6604a169b99ef9e73caa69" title="Shift data into the JTAG state-machine.">jtagShiftInOnly()</a></code>, <code><a class="el" href="libfpgalink_8h.html#abeabe9c6b30bee45a71560e5252d3d64" title="Shift data into and out of the JTAG state-machine.">jtagShiftInOut()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a618f685e40c8688ae202eae4d78649e3" title="Clock transitionCount bits from bitPattern into TMS, starting with the LSB.">jtagClockFSM()</a></code>, <code><a class="el" href="libfpgalink_8h.html#aff511cfdba78e8943282a0d29acfd42b" title="Toggle TCK numClocks times.">jtagClocks()</a></code>, <code><a class="el" href="libfpgalink_8h.html#aae2d0358833df24c04350cf804c63d22" title="Get the physical port number of the specified logical port.">progGetPort()</a></code>, <code><a class="el" href="libfpgalink_8h.html#aca840e749e80dc01fada76fb151cd8b5" title="Get the physical bit number of the specified logical port.">progGetBit()</a></code>, <code><a class="el" href="libfpgalink_8h.html#ad5df0a1ae846da4860083fdbe27e6c04" title="Send a number of whole bytes over SPI, either LSB-first or MSB-first.">spiSend()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a414f5196eddbb5e79a7e2a85ebdfbe35" title="Receive a number of whole bytes over SPI, either LSB-first or MSB-first.">spiRecv()</a></code> and <code><a class="el" href="libfpgalink_8h.html#a7d1aecb85d5d4d07b180762458e15690" title="Swap the bits in a byte array.">spiBitSwap()</a></code>.</p>
<p>This function merely returns a flag determined by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>, so it cannot fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An 8-bit integer: 1 if the device supports NeroProg, else 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fc3d09dd96583c9219c1a0343aecbf1"></a><!-- doxytag: member="libfpgalink.h::flIsCommCapable" ref="a9fc3d09dd96583c9219c1a0343aecbf1" args="(struct FLContext *handle, uint8 conduit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 flIsCommCapable </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>conduit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check to see if the device supports CommFPGA. </p>
<p>CommFPGA is a set of channel read/write protocols. The micro may implement several different CommFPGA protocols, distinguished by the chosen conduit. A micro will typically implement its first CommFPGA protocol on conduit 1, and additional protocols on conduit 2, 3 etc. Conduit 0 is reserved for communication over JTAG using a virtual TAP state machine implemented in the FPGA, and is not implemented yet.</p>
<p>This function returns 1 if the micro supports CommFPGA on the chosen conduit, else 0.</p>
<p>Note that this function can only know the capabilities of the micro itself; it cannot determine whether the FPGA contains suitable logic to implement the protocol, or even whether there is an FPGA physically wired to the micro in the first place.</p>
<p>An affirmative response means you are free to call <code><a class="el" href="libfpgalink_8h.html#a2afc988a5fa70e4c273fe60595d61799" title="Check to see if the FPGA is running.">flIsFPGARunning()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a16b33b61b48b288f370b7b4483e5816f" title="Synchronously read one or more bytes from the specified channel.">flReadChannel()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a24aeb007ae3a83ca2a5d745c023beadd" title="Synchronously write one or more bytes to the specified channel.">flWriteChannel()</a></code>, <code><a class="el" href="libfpgalink_8h.html#acd7c2694cbafa6df84c3b9f9fa5a1109" title="Set the chunk size to be used for future async writes.">flSetAsyncWriteChunkSize()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a4f497ab3ea733a6dc679c23c83b7a13a" title="Asynchronously write one or more bytes to the specified channel.">flWriteChannelAsync()</a></code>, <code><a class="el" href="libfpgalink_8h.html#ae4a0003f5fcf0e483f5373c95cce6438" title="Flush out any pending asynchronous writes.">flFlushAsyncWrites()</a></code> <code><a class="el" href="libfpgalink_8h.html#a0f7c12381f2353ea1741747051996940" title="Wait for confirmation that pending asynchronous writes were received by the micro.">flAwaitAsyncWrites()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a4513434ff0d3d57d951f6b25189938b0" title="Submit an asynchronous read of one or more bytes from the specified channel.">flReadChannelAsyncSubmit()</a></code>, and <code><a class="el" href="libfpgalink_8h.html#a80ec3f7e30e605c744d2a631c73110bb" title="Await the data from a previously-submitted asynchronous read.">flReadChannelAsyncAwait()</a></code>.</p>
<p>This function merely returns information determined by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>, so it cannot fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">conduit</td><td>The conduit you're interested in (this will typically be 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An 8-bit integer: 1 if the device supports CommFPGA, else 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ac537f96c6d8b117391b5233f70bf0cba"></a><!-- doxytag: member="libfpgalink.h::flGetFirmwareID" ref="ac537f96c6d8b117391b5233f70bf0cba" args="(struct FLContext *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 flGetFirmwareID </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the firmware ID. </p>
<p>Each firmware (or fork of an existing firmware) has its own 16-bit ID, which this function retrieves.</p>
<p>This function merely returns information determined by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>, so it cannot fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 16-bit unsigned integer giving the firmware ID. </dd></dl>

</div>
</div>
<a class="anchor" id="ac07c92e2752b9280496d32c8e9ff5df5"></a><!-- doxytag: member="libfpgalink.h::flGetFirmwareVersion" ref="ac07c92e2752b9280496d32c8e9ff5df5" args="(struct FLContext *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 flGetFirmwareVersion </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the firmware version. </p>
<p>Each firmware knows the GitHub tag from which is was built, or if it was built from a trunk, it knows the date on which it was built. This function returns a 32-bit integer giving that information. If printed as a hex number, it gives an eight-digit ISO date.</p>
<p>This function merely returns information determined by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>, so it cannot fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit unsigned integer giving the firmware version. </dd></dl>

</div>
</div>
<a class="anchor" id="ae33aab1191c1f69a48152a186b239575"></a><!-- doxytag: member="libfpgalink.h::flSelectConduit" ref="ae33aab1191c1f69a48152a186b239575" args="(struct FLContext *handle, uint8 conduit, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flSelectConduit </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>conduit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select a different conduit. </p>
<p>Select a different conduit for CommFPGA communication. Typically a micro will implement its first CommFPGA protocol on conduit 1. It may or may not also implement others on conduit 2, 3, 4 etc. It may also implement comms-over-JTAG using a virtual TAP FSM on the FPGA. You can use <code><a class="el" href="libfpgalink_8h.html#a9fc3d09dd96583c9219c1a0343aecbf1" title="Check to see if the device supports CommFPGA.">flIsCommCapable()</a></code> to determine whether the micro supports CommFPGA on a given conduit.</p>
<p>If mixing NeroProg operations with CommFPGA operations, it <b>may</b> be necessary to switch conduits. For example, if your PCB is wired to use some of the CommFPGA signals during programming, you will have to switch back and forth. But if the pins used for CommFPGA are independent of the pins used for NeroProg, you need only select the correct conduit on startup and then leave it alone.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">conduit</td><td>The conduit to select (current range 0-15). </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_USB_ERR</code> if the device doesn't respond, or the conduit is out of range. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2afc988a5fa70e4c273fe60595d61799"></a><!-- doxytag: member="libfpgalink.h::flIsFPGARunning" ref="a2afc988a5fa70e4c273fe60595d61799" args="(struct FLContext *handle, uint8 *isRunning, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flIsFPGARunning </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>isRunning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check to see if the FPGA is running. </p>
<p>This may only be called if <code><a class="el" href="libfpgalink_8h.html#a9fc3d09dd96583c9219c1a0343aecbf1" title="Check to see if the device supports CommFPGA.">flIsCommCapable()</a></code> returns true. It merely verifies that the FPGA is asserting that it's ready to read commands on the chosen conduit. Some conduits may not have the capability to determine this, and will therefore just optimistically report true. Before calling this function you should verify that the FPGALink device actually supports CommFPGA using <code><a class="el" href="libfpgalink_8h.html#a9fc3d09dd96583c9219c1a0343aecbf1" title="Check to see if the device supports CommFPGA.">flIsCommCapable()</a></code>, and select the conduit you wish to use with <code><a class="el" href="libfpgalink_8h.html#ae33aab1191c1f69a48152a186b239575" title="Select a different conduit.">flSelectConduit()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">isRunning</td><td>A pointer to an 8-bit integer which will be set on exit to 1 if the FPGA is running, else 0. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if all is well (<code>*isRunning</code> is valid).</li>
<li><code>FL_PROTOCOL_ERR</code> if the device does not support CommFPGA. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a16b33b61b48b288f370b7b4483e5816f"></a><!-- doxytag: member="libfpgalink.h::flReadChannel" ref="a16b33b61b48b288f370b7b4483e5816f" args="(struct FLContext *handle, uint8 channel, size_t numBytes, uint8 *buffer, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flReadChannel </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously read one or more bytes from the specified channel. </p>
<p>Read <code>numBytes</code> bytes from the FPGA channel <code>channel</code> into the <code>buffer</code> array. Before calling this function you should verify that the FPGALink device actually supports CommFPGA using <code><a class="el" href="libfpgalink_8h.html#a9fc3d09dd96583c9219c1a0343aecbf1" title="Check to see if the device supports CommFPGA.">flIsCommCapable()</a></code>.</p>
<p>Because this function is synchronous, it will block until the data has been returned. You must not use this function between an async read submit...await pair.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">channel</td><td>The FPGA channel to read (0-127). </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">buffer</td><td>The address of a buffer to store the bytes read from the FPGA. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_USB_ERR</code> if a USB read or write error occurred.</li>
<li><code>FL_PROTOCOL_ERR</code> if the device does not support CommFPGA. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a24aeb007ae3a83ca2a5d745c023beadd"></a><!-- doxytag: member="libfpgalink.h::flWriteChannel" ref="a24aeb007ae3a83ca2a5d745c023beadd" args="(struct FLContext *handle, uint8 channel, size_t numBytes, const uint8 *sendData, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flWriteChannel </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously write one or more bytes to the specified channel. </p>
<p>Write <code>numBytes</code> bytes from the <code>sendData</code> array to FPGA channel <code>channel</code>. Before calling this function you should verify that the FPGALink device actually supports CommFPGA using <code><a class="el" href="libfpgalink_8h.html#a9fc3d09dd96583c9219c1a0343aecbf1" title="Check to see if the device supports CommFPGA.">flIsCommCapable()</a></code>.</p>
<p>Because this function is synchronous, it will block until the OS has confirmed that the data has been correctly sent over USB and received by the micro. It cannot confirm that the data has been received by the FPGA however: it may be waiting in the micro's output buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">channel</td><td>The FPGA channel to write (0-127). </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">sendData</td><td>The address of the array of bytes to be written to the FPGA. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_ALLOC_ERR</code> if there was a memory allocation failure.</li>
<li><code>FL_USB_ERR</code> if a USB write error occurred.</li>
<li><code>FL_PROTOCOL_ERR</code> if the device does not support CommFPGA.</li>
<li><code>FL_BAD_STATE</code> if there are async reads in progress. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="acd7c2694cbafa6df84c3b9f9fa5a1109"></a><!-- doxytag: member="libfpgalink.h::flSetAsyncWriteChunkSize" ref="acd7c2694cbafa6df84c3b9f9fa5a1109" args="(struct FLContext *handle, uint16 chunkSize, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flSetAsyncWriteChunkSize </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>chunkSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the chunk size to be used for future async writes. </p>
<p>By default, the <code><a class="el" href="libfpgalink_8h.html#a4f497ab3ea733a6dc679c23c83b7a13a" title="Asynchronously write one or more bytes to the specified channel.">flWriteChannelAsync()</a></code> function buffers up to 64KiB of data before sending anything over USB. Chunking the data in this way is more efficient than sending lots of little messages. However, the choice of chunk size affects the steady-state throughput in interesting ways. If you need to, you can choose to make the chunks smaller than 64KiB.</p>
<p>You should not call this when there is some send data buffered. You should either call this before the first call to <code><a class="el" href="libfpgalink_8h.html#a4f497ab3ea733a6dc679c23c83b7a13a" title="Asynchronously write one or more bytes to the specified channel.">flWriteChannelAsync()</a></code>, or call it immediately after a call to <code><a class="el" href="libfpgalink_8h.html#ae4a0003f5fcf0e483f5373c95cce6438" title="Flush out any pending asynchronous writes.">flFlushAsyncWrites()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">chunkSize</td><td>The new chunksize in bytes. Passing zero sets the chunkSize to 64KiB. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_BAD_STATE</code> if there is some outstanding send data. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4f497ab3ea733a6dc679c23c83b7a13a"></a><!-- doxytag: member="libfpgalink.h::flWriteChannelAsync" ref="a4f497ab3ea733a6dc679c23c83b7a13a" args="(struct FLContext *handle, uint8 channel, size_t numBytes, const uint8 *sendData, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flWriteChannelAsync </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously write one or more bytes to the specified channel. </p>
<p>Write <code>numBytes</code> bytes from the <code>sendData</code> array to FPGA channel <code>channel</code>. Before calling this function you should verify that the FPGALink device actually supports CommFPGA using <code><a class="el" href="libfpgalink_8h.html#a9fc3d09dd96583c9219c1a0343aecbf1" title="Check to see if the device supports CommFPGA.">flIsCommCapable()</a></code>.</p>
<p>This function is asynchronous. That means it will return immediately, usually before anything has been actually sent over USB. If the operation fails, you will not be notified of the failure until a future call to <code><a class="el" href="libfpgalink_8h.html#a0f7c12381f2353ea1741747051996940" title="Wait for confirmation that pending asynchronous writes were received by the micro.">flAwaitAsyncWrites()</a></code> or <code><a class="el" href="libfpgalink_8h.html#a80ec3f7e30e605c744d2a631c73110bb" title="Await the data from a previously-submitted asynchronous read.">flReadChannelAsyncAwait()</a></code>. The data is copied internally, so there's no need to worry about preserving the data: it's safe to call <code><a class="el" href="libfpgalink_8h.html#a4f497ab3ea733a6dc679c23c83b7a13a" title="Asynchronously write one or more bytes to the specified channel.">flWriteChannelAsync()</a></code> on a stack-allocated array, for example.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">channel</td><td>The FPGA channel to write (0-127). </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">sendData</td><td>The address of the array of bytes to be written to the FPGA. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_ALLOC_ERR</code> if there was a memory allocation failure.</li>
<li><code>FL_USB_ERR</code> if a USB write error occurred.</li>
<li><code>FL_PROTOCOL_ERR</code> if the device does not support CommFPGA. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae4a0003f5fcf0e483f5373c95cce6438"></a><!-- doxytag: member="libfpgalink.h::flFlushAsyncWrites" ref="ae4a0003f5fcf0e483f5373c95cce6438" args="(struct FLContext *handle, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flFlushAsyncWrites </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush out any pending asynchronous writes. </p>
<p>Flush any writes that have been buffered up, or do nothing if no writes have been buffered. This only triggers the send over USB; it does not guarantee the micro successfully received the data. See <code><a class="el" href="libfpgalink_8h.html#a0f7c12381f2353ea1741747051996940" title="Wait for confirmation that pending asynchronous writes were received by the micro.">flAwaitAsyncWrites()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_USB_ERR</code> if a USB write error occurred.</li>
<li><code>FL_PROTOCOL_ERR</code> if the device does not support CommFPGA. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0f7c12381f2353ea1741747051996940"></a><!-- doxytag: member="libfpgalink.h::flAwaitAsyncWrites" ref="a0f7c12381f2353ea1741747051996940" args="(struct FLContext *handle, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flAwaitAsyncWrites </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for confirmation that pending asynchronous writes were received by the micro. </p>
<p>The first thing this does is to call <code><a class="el" href="libfpgalink_8h.html#ae4a0003f5fcf0e483f5373c95cce6438" title="Flush out any pending asynchronous writes.">flFlushAsyncWrites()</a></code> to flush out any outstanding write commands. It will then block until the OS confirms that all the asynchronous write commands sent by <code><a class="el" href="libfpgalink_8h.html#a4f497ab3ea733a6dc679c23c83b7a13a" title="Asynchronously write one or more bytes to the specified channel.">flWriteChannelAsync()</a></code> were correctly sent over USB and received by the micro. It cannot confirm that that the writes were received by the FPGA however: they may be waiting in the micro's output buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_USB_ERR</code> if one of the outstanding async operations failed.</li>
<li><code>FL_PROTOCOL_ERR</code> if the device does not support CommFPGA.</li>
<li><code>FL_BAD_STATE</code> if there are async reads in progress. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4513434ff0d3d57d951f6b25189938b0"></a><!-- doxytag: member="libfpgalink.h::flReadChannelAsyncSubmit" ref="a4513434ff0d3d57d951f6b25189938b0" args="(struct FLContext *handle, uint8 channel, uint32 numBytes, uint8 *buffer, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flReadChannelAsyncSubmit </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit an asynchronous read of one or more bytes from the specified channel. </p>
<p>Submit an asynchronous read of <code>numBytes</code> bytes from the FPGA channel <code>channel</code>. You can request at most 64KiB of data asynchronously. Before calling this function you should verify that the FPGALink device actually supports CommFPGA using <code><a class="el" href="libfpgalink_8h.html#a9fc3d09dd96583c9219c1a0343aecbf1" title="Check to see if the device supports CommFPGA.">flIsCommCapable()</a></code>.</p>
<p>This function is asynchronous. That means it will return immediately, usually before the read request has been sent over USB. You will not find out the result of the read until you later call <code><a class="el" href="libfpgalink_8h.html#a80ec3f7e30e605c744d2a631c73110bb" title="Await the data from a previously-submitted asynchronous read.">flReadChannelAsyncAwait()</a></code> - this will give you your data, or tell you what went wrong.</p>
<p>You should always ensure that for each call to <code><a class="el" href="libfpgalink_8h.html#a4513434ff0d3d57d951f6b25189938b0" title="Submit an asynchronous read of one or more bytes from the specified channel.">flReadChannelAsyncSubmit()</a></code>, there is a matching call to <code><a class="el" href="libfpgalink_8h.html#a80ec3f7e30e605c744d2a631c73110bb" title="Await the data from a previously-submitted asynchronous read.">flReadChannelAsyncAwait()</a></code>. You should not call any of <code><a class="el" href="libfpgalink_8h.html#acd7c2694cbafa6df84c3b9f9fa5a1109" title="Set the chunk size to be used for future async writes.">flSetAsyncWriteChunkSize()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a0f7c12381f2353ea1741747051996940" title="Wait for confirmation that pending asynchronous writes were received by the micro.">flAwaitAsyncWrites()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a24aeb007ae3a83ca2a5d745c023beadd" title="Synchronously write one or more bytes to the specified channel.">flWriteChannel()</a></code> or <code><a class="el" href="libfpgalink_8h.html#a16b33b61b48b288f370b7b4483e5816f" title="Synchronously read one or more bytes from the specified channel.">flReadChannel()</a></code> between a submit...await pair.</p>
<p>USB host controllers typically need just one level of nesting of submit...await pairs to keep them busy. That means sequences like submit, submit, await, submit, await, submit, ..., await, await.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">channel</td><td>The FPGA channel to read (0-127). </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes to read, &lt;= 64KiB (hence <code>uint32</code> rather than <code>size_t</code>). </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer to receive the data, or <code>NULL</code> if you want to borrow one. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_USB_ERR</code> if a USB read or write error occurred.</li>
<li><code>FL_PROTOCOL_ERR</code> if the device does not support CommFPGA. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a80ec3f7e30e605c744d2a631c73110bb"></a><!-- doxytag: member="libfpgalink.h::flReadChannelAsyncAwait" ref="a80ec3f7e30e605c744d2a631c73110bb" args="(struct FLContext *handle, const uint8 **recvData, uint32 *requestLength, uint32 *actualLength, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flReadChannelAsyncAwait </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 **&#160;</td>
          <td class="paramname"><em>recvData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>requestLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>actualLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Await the data from a previously-submitted asynchronous read. </p>
<p>Block until the outcome of a previous call to <code><a class="el" href="libfpgalink_8h.html#a4513434ff0d3d57d951f6b25189938b0" title="Submit an asynchronous read of one or more bytes from the specified channel.">flReadChannelAsyncSubmit()</a></code> is known. If the read was successful, you are given the resulting data. If not, an error code/message.</p>
<p>On successful outcome, the three out parameters are populated with a pointer to the FPGA data, the requested length and the actual length. Unless the FPGA and micro support early termination of reads, the two lengths will be identical.</p>
<p>Unless you provided your own buffer when you called <code><a class="el" href="libfpgalink_8h.html#a4513434ff0d3d57d951f6b25189938b0" title="Submit an asynchronous read of one or more bytes from the specified channel.">flReadChannelAsyncSubmit()</a></code>, the data returned is stored in an internal buffer. It is guaranteed to remain valid until your next call to any of the CommFPGA functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">recvData</td><td>A pointer to a <code>const uint8 *</code> which will be set on exit to point to a buffer containing the bytes read from the FPGA. </td></tr>
    <tr><td class="paramname">requestLength</td><td>A pointer to a <code>uint32</code> which will be set on exit to the number of bytes requested in the corresponding call to <code><a class="el" href="libfpgalink_8h.html#a4513434ff0d3d57d951f6b25189938b0" title="Submit an asynchronous read of one or more bytes from the specified channel.">flReadChannelAsyncSubmit()</a></code>. </td></tr>
    <tr><td class="paramname">actualLength</td><td>A pointer to a <code>uint32</code> which will be set on exit to the number of bytes actually read from the FPGA. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_USB_ERR</code> if one of the outstanding async operations failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7fbc8058cc9c3afe924357be1836bc3c"></a><!-- doxytag: member="libfpgalink.h::flResetToggle" ref="a7fbc8058cc9c3afe924357be1836bc3c" args="(struct FLContext *handle, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flResetToggle </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Under some circumstances (e.g a Linux VM running on a Windows VirtualBox host talking to an FX2-based FPGALink device), it's necessary to manually reset the USB endpoints before doing any reads or writes. I admit this is hacky, and probably represents a bug somewhere.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_USB_ERR</code> if a USB error occurred. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aee1237800fd15040940c9a288fef4c40"></a><!-- doxytag: member="libfpgalink.h::flProgram" ref="aee1237800fd15040940c9a288fef4c40" args="(struct FLContext *handle, const char *progConfig, const char *progFile, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flProgram </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>progConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>progFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Program a device using the specified file. </p>
<p>This will program an FPGA or CPLD using the specified microcontroller ports and the specified programming file. Several programming algorithms are supported (JTAG, Xilinx Slave-Serial, Xilinx SelectMap and Altera Passive-Serial). In each case, it's necessary to tell the micro which ports to use. Here are some examples:</p>
<p>A Digilent board using JTAG: <code>progConfig="J:D0D2D3D4"</code>:</p>
<ul>
<li>TDO: PD0</li>
<li>TDI: PD2</li>
<li>TMS: PD3</li>
<li>TCK: PD4</li>
</ul>
<p>MakeStuff LX9 using JTAG: <code>progConfig="J:A7A0A3A1"</code>:</p>
<ul>
<li>TDO: PA7</li>
<li>TDI: PA0</li>
<li>TMS: PA3</li>
<li>TCK: PA1</li>
</ul>
<p>EP2C5 Mini Board using Altera Passive-Serial: <code>progConfig="AS:B5B6B1B2"</code> (note that the board normally connects MSEL[1:0] to ground, hard-coding it in Active-Serial mode. For Passive-Serial to work you need to lift pin 85 and pull it up to VCC):</p>
<ul>
<li>nCONFIG: PD5</li>
<li>CONF_DONE: PD6</li>
<li>DCLK: PD1</li>
<li>DATA0: PD2</li>
</ul>
<p>Aessent aes220 using Xilinx Slave-Serial: <code>progConfig="XS:D0D5D1D6A7[D3?,B1+,B5+,B3+]"</code>:</p>
<ul>
<li>PROG_B: PD0</li>
<li>INIT_B: PD5</li>
<li>DONE: PD1</li>
<li>CCLK: PD6</li>
<li>DIN: PA7</li>
<li>Tristate DOUT (PD3)</li>
<li>Drive M[2:0]="111" (PB1, PB5, PB3) for Slave-Serial</li>
</ul>
<p>Aessent aes220 using Xilinx SelectMAP: <code>progConfig="XP:D0D5D1D6A01234567[B4-,D2-,D3?,B1+,B5+,B3-]"</code>:</p>
<ul>
<li>PROG_B: PD0</li>
<li>INIT_B: PD5</li>
<li>DONE: PD1</li>
<li>CCLK: PD6</li>
<li>D[7:0]: PA[7:0]</li>
<li>Drive RDWR_B="0" (PB4)</li>
<li>Drive CSI_B="0" (PD2)</li>
<li>Tristate DOUT (PD3)</li>
<li>Drive M[2:0]="110" (PB1, PB5, PB3) for SelectMAP</li>
</ul>
<p>Note that this approach of specifying and implementing many disparate programming algorithms on the host side in terms of a much smaller set of building-block operations on the microcontroller is optimized for microcontrollers which support efficient remapping of I/O pins. For example the FX2 has a Von Neumann architecture where both code and data are stored in a single RAM-based address space, so port remapping can easily be achieved with self-modifying code. Conversely, the AVRs have Harvard architecture, where code and data are in separate address spaces, with code in flash so it cannot be self-modified. And actually, the AVR firmware is more likely to be tuned to a specific board layout than the more generic FX2 firmware.</p>
<p>So, the bottom line is, even if you're using a microcontroller whose port pins are hard-coded, you still have to supply the port pins to use when you call functions expecting <code>progConfig</code>.</p>
<p>You can either append the programming filename to the end of <code>progConfig</code> (e.g <code>"J:A7A0A3A1:fpga.xsvf"</code>) or you can supply the programming filename separately in <code>progFile</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">progConfig</td><td>The port configuration described above. </td></tr>
    <tr><td class="paramname">progFile</td><td>The name of the programming file, or <code>NULL</code> if it's already given in <code>progConfig</code>. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_ALLOC_ERR</code> if we ran out of memory during programming.</li>
<li><code>FL_USB_ERR</code> if a USB error occurred.</li>
<li><code>FL_FILE_ERR</code> if the programming file is unreadable or an unexpected format.</li>
<li><code>FL_UNSUPPORTED_CMD_ERR</code> if an XSVF file contains an unsupported command.</li>
<li><code>FL_UNSUPPORTED_DATA_ERR</code> if an XSVF file contains an unsupported XENDDR/XENDIR.</li>
<li><code>FL_UNSUPPORTED_SIZE_ERR</code> if an XSVF command is too long.</li>
<li><code>FL_SVF_PARSE_ERR</code> if an SVF file is unparseable.</li>
<li><code>FL_CONF_FORMAT</code> if <code>progConfig</code> is malformed.</li>
<li><code>FL_PROG_PORT_MAP</code> if the micro was unable to map its ports to those given.</li>
<li><code>FL_PROG_SEND</code> if the micro refused to accept programming data.</li>
<li><code>FL_PROG_RECV</code> if the micro refused to provide programming data.</li>
<li><code>FL_PROG_SHIFT</code> if the micro refused to begin a JTAG shift operation.</li>
<li><code>FL_PROG_JTAG_FSM</code> if the micro refused to navigate the TAP state-machine.</li>
<li><code>FL_PROG_JTAG_CLOCKS</code> if the micro refused to send JTAG clocks.</li>
<li><code>FL_PROG_SVF_COMPARE</code> if an SVF/XSVF compare operation failed.</li>
<li><code>FL_PROG_SVF_UNKNOWN_CMD</code> if an SVF/XSVF unknown command was encountered.</li>
<li><code>FL_PROG_ERR</code> if the FPGA failed to start after programming.</li>
<li><code>FL_PORT_IO</code> if the micro refused to configure one of its ports. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af2e29b8b5a6a6d8ec1e453cdb4682466"></a><!-- doxytag: member="libfpgalink.h::flProgramBlob" ref="af2e29b8b5a6a6d8ec1e453cdb4682466" args="(struct FLContext *handle, const char *progConfig, uint32 numBytes, const uint8 *progData, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flProgramBlob </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>progConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>progData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Program a device using the specified programming blob. </p>
<p>This is similar to <code><a class="el" href="libfpgalink_8h.html#aee1237800fd15040940c9a288fef4c40" title="Program a device using the specified file.">flProgram()</a></code>, except that instead of reading the programming information from a file, it runs the programming operation from a binary blob already stored in memory. For JTAG programming this is assumed to be a CSVF file; for Xilinx programming it is assumed to be a raw bitstream (.bin) file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">progConfig</td><td>The port configuration described in <code><a class="el" href="libfpgalink_8h.html#aee1237800fd15040940c9a288fef4c40" title="Program a device using the specified file.">flProgram()</a></code>. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes of programming data. </td></tr>
    <tr><td class="paramname">progData</td><td>A pointer to the start of the programming data. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_USB_ERR</code> if a USB error occurred.</li>
<li><code>FL_CONF_FORMAT</code> if <code>progConfig</code> is malformed.</li>
<li><code>FL_PROG_PORT_MAP</code> if the micro was unable to map its ports to those given.</li>
<li><code>FL_PROG_SEND</code> if the micro refused to accept programming data.</li>
<li><code>FL_PROG_RECV</code> if the micro refused to provide programming data.</li>
<li><code>FL_PROG_SHIFT</code> if the micro refused to begin a JTAG shift operation.</li>
<li><code>FL_PROG_JTAG_FSM</code> if the micro refused to navigate the TAP state-machine.</li>
<li><code>FL_PROG_JTAG_CLOCKS</code> if the micro refused to send JTAG clocks.</li>
<li><code>FL_PROG_SVF_COMPARE</code> if an SVF/XSVF compare operation failed.</li>
<li><code>FL_PROG_SVF_UNKNOWN_CMD</code> if an SVF/XSVF unknown command was encountered.</li>
<li><code>FL_PROG_ERR</code> if the FPGA failed to start after programming.</li>
<li><code>FL_PORT_IO</code> if the micro refused to configure one of its ports. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a54789a8a9da4ab5f9c6b7265cac80c6d"></a><!-- doxytag: member="libfpgalink.h::jtagScanChain" ref="a54789a8a9da4ab5f9c6b7265cac80c6d" args="(struct FLContext *handle, const char *portConfig, uint32 *numDevices, uint32 *deviceArray, uint32 arraySize, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> jtagScanChain </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>portConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>numDevices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>deviceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>arraySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan the JTAG chain and return an array of IDCODEs. </p>
<p>Count the number of devices on the JTAG chain, and set <code>*numDevices</code> accordingly. Then, if <code>deviceArray</code> is not <code>NULL</code>, populate it with at most <code>arraySize</code> IDCODEs, in chain order.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">portConfig</td><td>The port bits to use for TDO, TDI, TMS &amp; TCK, e.g "D0D2D3D4". </td></tr>
    <tr><td class="paramname">numDevices</td><td>A pointer to a <code>uint32</code> which will be set on exit to the number of devices in the JTAG chain. </td></tr>
    <tr><td class="paramname">deviceArray</td><td>A pointer to an array of <code>uint32</code>, which will be populated on exit with a list of IDCODEs in chain order. May be <code>NULL</code>, in which case the function returns after setting <code>*numDevices</code>. </td></tr>
    <tr><td class="paramname">arraySize</td><td>The number of 32-bit IDCODE slots available in <code>deviceArray</code>. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_CONF_FORMAT</code> if <code>portConfig</code> is malformed.</li>
<li><code>FL_PROG_PORT_MAP</code> if the micro was unable to map its ports to those given.</li>
<li><code>FL_PROG_SEND</code> if the micro refused to accept programming data.</li>
<li><code>FL_PROG_RECV</code> if the micro refused to provide programming data.</li>
<li><code>FL_PROG_SHIFT</code> if the micro refused to begin a JTAG shift operation.</li>
<li><code>FL_PROG_JTAG_FSM</code> if the micro refused to navigate the TAP state-machine.</li>
<li><code>FL_PORT_IO</code> if the micro refused to configure one of its ports. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1d42bc3e63b9cea034add652e1e11df5"></a><!-- doxytag: member="libfpgalink.h::progOpen" ref="a1d42bc3e63b9cea034add652e1e11df5" args="(struct FLContext *handle, const char *portConfig, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> progOpen </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>portConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open an SPI/JTAG connection. </p>
<p>Open a SPI/JTAG connection using the supplied <code>portConfig</code>. You must open a connection before calling <code><a class="el" href="libfpgalink_8h.html#abeabe9c6b30bee45a71560e5252d3d64" title="Shift data into and out of the JTAG state-machine.">jtagShiftInOut()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a3c24aed4dc6604a169b99ef9e73caa69" title="Shift data into the JTAG state-machine.">jtagShiftInOnly()</a></code>, <code><a class="el" href="libfpgalink_8h.html#a618f685e40c8688ae202eae4d78649e3" title="Clock transitionCount bits from bitPattern into TMS, starting with the LSB.">jtagClockFSM()</a></code>, <code><a class="el" href="libfpgalink_8h.html#aff511cfdba78e8943282a0d29acfd42b" title="Toggle TCK numClocks times.">jtagClocks()</a></code>, <code><a class="el" href="libfpgalink_8h.html#ad5df0a1ae846da4860083fdbe27e6c04" title="Send a number of whole bytes over SPI, either LSB-first or MSB-first.">spiSend()</a></code> or <code><a class="el" href="libfpgalink_8h.html#a414f5196eddbb5e79a7e2a85ebdfbe35" title="Receive a number of whole bytes over SPI, either LSB-first or MSB-first.">spiRecv()</a></code>. And you must close the connection when you're finished, with <code><a class="el" href="libfpgalink_8h.html#a52e3a1c5303e9b0bee6c749561e0c22f" title="Close an SPI/JTAG connection.">progClose()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">portConfig</td><td>The port bits to use for MISO(TDO), MOSI(TDI), SS(TMS) and SCK(TCK), e.g "D0D2D3D4". </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_CONF_FORMAT</code> if <code>portConfig</code> is malformed.</li>
<li><code>FL_PROG_PORTMAP</code> if the micro refused to map its ports to those given.</li>
<li><code>FL_PORT_IO</code> if the micro refused to configure one of its ports. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a52e3a1c5303e9b0bee6c749561e0c22f"></a><!-- doxytag: member="libfpgalink.h::progClose" ref="a52e3a1c5303e9b0bee6c749561e0c22f" args="(struct FLContext *handle, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> progClose </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close an SPI/JTAG connection. </p>
<p>Close an SPI/JTAG connection previously opened by <code><a class="el" href="libfpgalink_8h.html#a1d42bc3e63b9cea034add652e1e11df5" title="Open an SPI/JTAG connection.">progOpen()</a></code>, and tri-state the four programming pins.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_PORT_IO</code> if the micro refused to configure one of its ports. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3c24aed4dc6604a169b99ef9e73caa69"></a><!-- doxytag: member="libfpgalink.h::jtagShiftInOnly" ref="a3c24aed4dc6604a169b99ef9e73caa69" args="(struct FLContext *handle, uint32 numBits, const uint8 *tdiData, uint8 isLast, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> jtagShiftInOnly </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>tdiData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>isLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shift data into the JTAG state-machine. </p>
<p>Shift <code>numBits</code> bits LSB-first from <code>tdiData</code> into TDI. If <code>isLast</code> is zero, leave the TAP state-machine in <code>Shift-xR</code>, otherwise exit to <code>Exit1-xR</code> on the final bit. If you want <code>tdiData</code> to be all zeros you can use <code>SHIFT_ZEROS</code>, or if you want it to be all ones you can use <code>SHIFT_ONES</code>. This is more efficient than explicitly sending an array containing all zeros or all 0xFFs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">numBits</td><td>The number of bits to clock into the JTAG state-machine. </td></tr>
    <tr><td class="paramname">tdiData</td><td>A pointer to the source data, or <code>SHIFT_ZEROS</code> or <code>SHIFT_ONES</code>. </td></tr>
    <tr><td class="paramname">isLast</td><td>Either 0 to remain in <code>Shift-xR</code>, or 1 to exit to <code>Exit1-xR</code>. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_PROG_SEND</code> if the micro refused to accept programming data.</li>
<li><code>FL_PROG_SHIFT</code> if the micro refused to begin a JTAG shift operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abeabe9c6b30bee45a71560e5252d3d64"></a><!-- doxytag: member="libfpgalink.h::jtagShiftInOut" ref="abeabe9c6b30bee45a71560e5252d3d64" args="(struct FLContext *handle, uint32 numBits, const uint8 *tdiData, uint8 *tdoData, uint8 isLast, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> jtagShiftInOut </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>tdiData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>tdoData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>isLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shift data into and out of the JTAG state-machine. </p>
<p>Shift <code>numBits</code> bits LSB-first from <code>tdiData</code> into TDI; at the same time shift the same number of bits LSB-first from TDO into <code>tdoData</code>. If <code>isLast</code> is zero, leave the TAP state-machine in <code>Shift-xR</code>, otherwise exit to <code>Exit1-xR</code> on the final bit. If you want <code>tdiData</code> to be all zeros you can use <code>SHIFT_ZEROS</code>, or if you want it to be all ones you can use <code>SHIFT_ONES</code>. This is more efficient than explicitly sending an array containing all zeros or all 0xFFs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">numBits</td><td>The number of bits to clock into and out of the JTAG state-machine. </td></tr>
    <tr><td class="paramname">tdiData</td><td>A pointer to the source data, or <code>SHIFT_ZEROS</code> or <code>SHIFT_ONES</code>. </td></tr>
    <tr><td class="paramname">tdoData</td><td>A pointer to a buffer to receive output data, or <code>NULL</code> if you don't care. </td></tr>
    <tr><td class="paramname">isLast</td><td>Either 0 to remain in <code>Shift-xR</code>, or 1 to exit to <code>Exit1-xR</code>. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_PROG_SEND</code> if the micro refused to accept programming data.</li>
<li><code>FL_PROG_RECV</code> if the micro refused to provide programming data.</li>
<li><code>FL_PROG_SHIFT</code> if the micro refused to begin a JTAG shift operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a618f685e40c8688ae202eae4d78649e3"></a><!-- doxytag: member="libfpgalink.h::jtagClockFSM" ref="a618f685e40c8688ae202eae4d78649e3" args="(struct FLContext *handle, uint32 bitPattern, uint8 transitionCount, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> jtagClockFSM </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>bitPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>transitionCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clock <code>transitionCount</code> bits from <code>bitPattern</code> into TMS, starting with the LSB. </p>
<p>Navigate the TAP state-machine by clocking an arbitrary sequence of bits into TMS.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">bitPattern</td><td>The pattern of bits to clock into TMS, LSB first. </td></tr>
    <tr><td class="paramname">transitionCount</td><td>The number of bits to clock. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_PROG_JTAG_FSM</code> if the micro refused to navigate the TAP state-machine. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aff511cfdba78e8943282a0d29acfd42b"></a><!-- doxytag: member="libfpgalink.h::jtagClocks" ref="aff511cfdba78e8943282a0d29acfd42b" args="(struct FLContext *handle, uint32 numClocks, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> jtagClocks </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numClocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Toggle TCK <code>numClocks</code> times. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">numClocks</td><td>The number of clocks to put out on TCK. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_PROG_JTAG_CLOCKS</code> if the micro refused to send JTAG clocks. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aae2d0358833df24c04350cf804c63d22"></a><!-- doxytag: member="libfpgalink.h::progGetPort" ref="aae2d0358833df24c04350cf804c63d22" args="(struct FLContext *handle, uint8 logicalPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 progGetPort </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>logicalPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the physical port number of the specified logical port. </p>
<p>Get the physical port number assigned to the specified logical port by the preceding call to <code><a class="el" href="libfpgalink_8h.html#a1d42bc3e63b9cea034add652e1e11df5" title="Open an SPI/JTAG connection.">progOpen()</a></code>. This is just a convenience function to avoid re-parsing the port config, which is typically supplied by the user as a string. For example, to send data to a SPI peripheral, you'll probably want to assert <code>SS</code>. So you'll want to call <code>progGetPort(handle, LP_SS)</code> to find out which physical port <code>SS</code> was assigned to.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">logicalPort</td><td>The <a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8">LogicalPort</a> to query for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The physical port mapped to the given <a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8">LogicalPort</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aca840e749e80dc01fada76fb151cd8b5"></a><!-- doxytag: member="libfpgalink.h::progGetBit" ref="aca840e749e80dc01fada76fb151cd8b5" args="(struct FLContext *handle, uint8 logicalPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 progGetBit </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>logicalPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the physical bit number of the specified logical port. </p>
<p>Get the physical bit number assigned to the specified logical port by the preceding call to <code><a class="el" href="libfpgalink_8h.html#a1d42bc3e63b9cea034add652e1e11df5" title="Open an SPI/JTAG connection.">progOpen()</a></code>. This is just a convenience function to avoid re-parsing the port config, which is typically supplied by the user as a string. For example, to send data to a SPI peripheral, you'll probably want to assert <code>SS</code>. So you'll want to call <code>progGetBit(handle, LP_SS)</code> to find out which physical port bit <code>SS</code> was assigned to.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">logicalPort</td><td>The <a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8">LogicalPort</a> to query for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The physical bit mapped to the given <a class="el" href="libfpgalink_8h.html#a507e3190734afde676318db508b389d8">LogicalPort</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5df0a1ae846da4860083fdbe27e6c04"></a><!-- doxytag: member="libfpgalink.h::spiSend" ref="ad5df0a1ae846da4860083fdbe27e6c04" args="(struct FLContext *handle, uint32 numBytes, const uint8 *sendData, uint8 bitOrder, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> spiSend </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>bitOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a number of whole bytes over SPI, either LSB-first or MSB-first. </p>
<p>Shift <code>numBytes</code> bytes from <code>sendData</code> into the microcontroller's SPI bus (if any), either MSB-first or LSB-first. You must have previously called <code><a class="el" href="libfpgalink_8h.html#a1d42bc3e63b9cea034add652e1e11df5" title="Open an SPI/JTAG connection.">progOpen()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">sendData</td><td>A pointer to the source data. </td></tr>
    <tr><td class="paramname">bitOrder</td><td>Either <code>SPI_MSBFIRST</code> or <code>SPI_LSBFIRST</code> (see <a class="el" href="libfpgalink_8h.html#a045d07d899642c93c7e9d9f2b23af156">BitOrder</a>). </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_ALLOC_ERR</code> if there was a memory allocation failure.</li>
<li><code>FL_USB_ERR</code> if USB communications failed whilst sending the data.</li>
<li><code>FL_PROTOCOL_ERR</code> if the device does not support SPI. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a414f5196eddbb5e79a7e2a85ebdfbe35"></a><!-- doxytag: member="libfpgalink.h::spiRecv" ref="a414f5196eddbb5e79a7e2a85ebdfbe35" args="(struct FLContext *handle, uint32 numBytes, uint8 *buffer, uint8 bitOrder, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> spiRecv </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>bitOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a number of whole bytes over SPI, either LSB-first or MSB-first. </p>
<p>Shift <code>numBytes</code> bytes from the microcontroller's SPI bus (if any) into <code>buffer</code>, either MSB-first or LSB-first. You must have previously called <code><a class="el" href="libfpgalink_8h.html#a1d42bc3e63b9cea034add652e1e11df5" title="Open an SPI/JTAG connection.">progOpen()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer to receive the data. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes to receive. </td></tr>
    <tr><td class="paramname">bitOrder</td><td>Either <code>SPI_MSBFIRST</code> or <code>SPI_LSBFIRST</code> (see <a class="el" href="libfpgalink_8h.html#a045d07d899642c93c7e9d9f2b23af156">BitOrder</a>). </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the operation completed successfully.</li>
<li><code>FL_USB_ERR</code> if USB communications failed whilst receiving the data.</li>
<li><code>FL_PROTOCOL_ERR</code> if the device does not support SPI. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7d1aecb85d5d4d07b180762458e15690"></a><!-- doxytag: member="libfpgalink.h::spiBitSwap" ref="a7d1aecb85d5d4d07b180762458e15690" args="(uint32 numBytes, uint8 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spiBitSwap </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the bits in a byte array. </p>
<p>Swap the bits in a byte, so that 0x01 -&gt; 0x80, 0x02 -&gt; 0x40 etc.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">numBytes</td><td>The number of bytes to be bit-swapped. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to an array of <code>uint8</code> to be bit-swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaee82d54cdcf6476a545885127d8a952"></a><!-- doxytag: member="libfpgalink.h::flLoadStandardFirmware" ref="aaee82d54cdcf6476a545885127d8a952" args="(const char *curVidPid, const char *newVidPid, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flLoadStandardFirmware </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>curVidPid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newVidPid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load standard FPGALink firmware into the FX2's RAM. </p>
<p>Load the FX2 chip at the "current" VID:PID with a precompiled firmware such that it will renumerate as the "new" VID:PID. The firmware is loaded into RAM, so the change is not permanent. Typically after calling <code><a class="el" href="libfpgalink_8h.html#aaee82d54cdcf6476a545885127d8a952" title="Load standard FPGALink firmware into the FX2&#39;s RAM.">flLoadStandardFirmware()</a></code> applications should wait for the renumeration to complete by calling <code><a class="el" href="libfpgalink_8h.html#ae188886270ebadecace4ff6d9f3086d4" title="Check if the given device is actually connected to the system.">flIsDeviceAvailable()</a></code> repeatedly until the "new" VID:PID becomes active.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">curVidPid</td><td>The current Vendor/Product (i.e VVVV:PPPP) of the FX2 device. </td></tr>
    <tr><td class="paramname">newVidPid</td><td>The Vendor/Product/Device (i.e VVVV:PPPP:DDDD) that you <b>want</b> the FX2 device to renumerate as. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the firmware loaded successfully.</li>
<li><code>FL_ALLOC_ERR</code> if there was a memory allocation failure.</li>
<li><code>FL_USB_ERR</code> if one of the VID:PIDs was invalid or the current VID:PID was not found.</li>
<li><code>FL_FX2_ERR</code> if there was a problem talking to the FX2. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a193d503842ab1351cf1c6cf08c3764cd"></a><!-- doxytag: member="libfpgalink.h::flFlashStandardFirmware" ref="a193d503842ab1351cf1c6cf08c3764cd" args="(struct FLContext *handle, const char *newVidPid, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flFlashStandardFirmware </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newVidPid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flash standard FPGALink firmware into the FX2's EEPROM. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function will make permanent changes to your hardware. Remember to make a backup copy of the existing EEPROM firmware with <code><a class="el" href="libfpgalink_8h.html#addfaedd80f0f40c9a1f134766235b23b" title="Save existing EEPROM data to a file.">flSaveFirmware()</a></code> before calling it.</dd></dl>
<p>Overwrite the FX2's EEPROM with a precompiled FPGALink firmware such that the board will enumerate on power-on as the "new" VID:PID.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">newVidPid</td><td>The Vendor/Product (i.e VVVV:PPPP) you want the FX2 to be on power-on. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the firmware flashed successfully.</li>
<li><code>FL_ALLOC_ERR</code> if there was a memory allocation failure.</li>
<li><code>FL_USB_ERR</code> if the VID:PID was invalid.</li>
<li><code>FL_FX2_ERR</code> if there was a problem talking to the FX2. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae14ca5ab58b526815c80ca09793e5e34"></a><!-- doxytag: member="libfpgalink.h::flLoadCustomFirmware" ref="ae14ca5ab58b526815c80ca09793e5e34" args="(const char *curVidPid, const char *fwFile, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flLoadCustomFirmware </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>curVidPid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fwFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load custom firmware (<code>.hex</code>) into the FX2's RAM. </p>
<p>Load the FX2 chip at the given VID:PID with a <code>.hex</code> firmware file. The firmware is loaded into RAM, so the change is not permanent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">curVidPid</td><td>The current Vendor/Product (i.e VVVV:PPPP) of the FX2 device. </td></tr>
    <tr><td class="paramname">fwFile</td><td>A <code>.hex</code> file containing new FX2 firmware to be loaded into the FX2's RAM. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the firmware loaded successfully.</li>
<li><code>FL_ALLOC_ERR</code> if there was a memory allocation failure.</li>
<li><code>FL_USB_ERR</code> if the VID:PID was invalid.</li>
<li><code>FL_FX2_ERR</code> if there was a problem talking to the FX2.</li>
<li><code>FL_FILE_ERR</code> if <code>fwFile</code> has a bad extension or could not be loaded. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1e67bed33586e784415791e5131e0b6b"></a><!-- doxytag: member="libfpgalink.h::flFlashCustomFirmware" ref="a1e67bed33586e784415791e5131e0b6b" args="(struct FLContext *handle, const char *fwFile, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flFlashCustomFirmware </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fwFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flash a custom firmware from a file into the FX2's EEPROM. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function will make permanent changes to your hardware. Remember to make a backup copy of the existing EEPROM firmware with <code><a class="el" href="libfpgalink_8h.html#addfaedd80f0f40c9a1f134766235b23b" title="Save existing EEPROM data to a file.">flSaveFirmware()</a></code> before calling it.</dd></dl>
<p>Overwrite the FX2's EEPROM with a custom firmware from a <code>.hex</code> or <code>.iic</code> file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">fwFile</td><td>A <code>.hex</code> or <code>.iic</code> file containing new FX2 firmware to be loaded into the FX2's EEPROM. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the firmware loaded successfully.</li>
<li><code>FL_ALLOC_ERR</code> if there was a memory allocation failure.</li>
<li><code>FL_FX2_ERR</code> if there was a problem talking to the FX2.</li>
<li><code>FL_FILE_ERR</code> if the firmware file could not be loaded. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="addfaedd80f0f40c9a1f134766235b23b"></a><!-- doxytag: member="libfpgalink.h::flSaveFirmware" ref="addfaedd80f0f40c9a1f134766235b23b" args="(struct FLContext *handle, uint32 eepromSize, const char *saveFile, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flSaveFirmware </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>eepromSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>saveFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save existing EEPROM data to a file. </p>
<p>The existing EEPROM firmware is saved to an <code>.iic</code> file, for backup purposes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">eepromSize</td><td>The size in kilobits of the EEPROM (e.g Nexys2's EEPROM is 128kbit). </td></tr>
    <tr><td class="paramname">saveFile</td><td>An <code>.iic</code> file to save the EEPROM to. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the firmware loaded successfully.</li>
<li><code>FL_ALLOC_ERR</code> if there was a memory allocation failure.</li>
<li><code>FL_FX2_ERR</code> if there was a problem talking to the FX2.</li>
<li><code>FL_FILE_ERR</code> if <code>saveFile</code> file could not be written. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a839988198379a25e7a0eaad38e00deab"></a><!-- doxytag: member="libfpgalink.h::flBootloader" ref="a839988198379a25e7a0eaad38e00deab" args="(struct FLContext *handle, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flBootloader </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put the AVR in DFU bootloader mode. </p>
<p>This is an AVR-specific utility function to make firmware upgrades easier on boards on which the /HWB and /RESET pins are not easily accesible. The "gordon" utility has an option to invoke this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the port access command completed successfully.</li>
<li><code>FL_USB_ERR</code> if the device is not running suitable FPGALink/AVR firmware. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a58a48f47195b55d4921659a74d9eed5d"></a><!-- doxytag: member="libfpgalink.h::flSleep" ref="a58a48f47195b55d4921659a74d9eed5d" args="(uint32 ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flSleep </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sleep for the specified number of milliseconds. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>The number of milliseconds to sleep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a549aade3b9ba7def5ef66e1f6315d1c7"></a><!-- doxytag: member="libfpgalink.h::flLoadFile" ref="a549aade3b9ba7def5ef66e1f6315d1c7" args="(const char *name, size_t *numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* flLoadFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a newly-allocated buffer with the specified file loaded into it. </p>
<p>The specified file is queried for its length, that length is written to the <code>numBytes</code> parameter. Then a buffer of that length is allocated, and the file is loaded into it and a pointer to the buffer returned. The responsibility for the buffer passes to the caller; it must be freed later by a call to <code><a class="el" href="libfpgalink_8h.html#a17909597ec81d8610c791a1ebf5f1400" title="Free a buffer previously returned by flLoadFile().">flFreeFile()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the file to load. </td></tr>
    <tr><td class="paramname">numBytes</td><td>A pointer to a <code>size_t</code> which will be populated with the file's length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated buffer, or <code>NULL</code> if the file could not be loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a17909597ec81d8610c791a1ebf5f1400"></a><!-- doxytag: member="libfpgalink.h::flFreeFile" ref="a17909597ec81d8610c791a1ebf5f1400" args="(uint8 *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flFreeFile </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a buffer previously returned by <code><a class="el" href="libfpgalink_8h.html#a549aade3b9ba7def5ef66e1f6315d1c7" title="Return a newly-allocated buffer with the specified file loaded into it.">flLoadFile()</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer previously returned by <code><a class="el" href="libfpgalink_8h.html#a549aade3b9ba7def5ef66e1f6315d1c7" title="Return a newly-allocated buffer with the specified file loaded into it.">flLoadFile()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd0ab7d13a50ef7b375f8baabb9d820a"></a><!-- doxytag: member="libfpgalink.h::flSingleBitPortAccess" ref="afd0ab7d13a50ef7b375f8baabb9d820a" args="(struct FLContext *handle, uint8 portNumber, uint8 bitNumber, uint8 pinConfig, uint8 *pinRead, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flSingleBitPortAccess </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>portNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>bitNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>pinConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>pinRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure a single port bit on the microcontroller. </p>
<p>With this function you can set a single microcontroller port bit to one of the enums in <a class="el" href="libfpgalink_8h.html#a3a8a28825ae2b26e757181838cf38a8f">PinConfig</a>, and read back the current state of the bit.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">portNumber</td><td>Which port to configure (i.e 0=PortA, 1=PortB, 2=PortC, etc). </td></tr>
    <tr><td class="paramname">bitNumber</td><td>The bit within the chosen port to use. </td></tr>
    <tr><td class="paramname">pinConfig</td><td>Either <code>PIN_INPUT</code>, <code>PIN_HIGH</code> or <code>PIN_LOW</code>. </td></tr>
    <tr><td class="paramname">pinRead</td><td>Pointer to a <code>uint8</code> to be set on exit to 0 or 1 depending on the current state of the pin. May be <code>NULL</code> if you're not interested. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the port access command completed successfully.</li>
<li><code>FL_PORT_IO</code> if the micro failed to respond to the port access command. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0130b09f179fc14ab9be191ca3083432"></a><!-- doxytag: member="libfpgalink.h::flMultiBitPortAccess" ref="a0130b09f179fc14ab9be191ca3083432" args="(struct FLContext *handle, const char *portConfig, uint32 *readState, const char **error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libfpgalink_8h.html#a9dbd76495d70a6f62b70274c35348271">FLStatus</a> flMultiBitPortAccess </td>
          <td>(</td>
          <td class="paramtype">struct FLContext *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>portConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>readState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure multiple port bits on the microcontroller. </p>
<p>With this function you can set multiple microcontroller port bits to either <code>PIN_INPUT</code>, <code>PIN_HIGH</code> or <code>PIN_LOW</code>, and read back the current state of each bit. This is achieved by sending a comma-separated list of port configurations, e.g "A12-,B2+,C7?". A "+" or a "-" suffix sets the port as an output, driven high or low respectively, and a "?" suffix sets the port as an input. The current state of up to 32 bits are returned in <code>readState</code>, LSB first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle returned by <code><a class="el" href="libfpgalink_8h.html#a241ac59f7ba96caba2e1262ffd0d4424" title="Open a connection to the FPGALink device at the specified VID and PID.">flOpen()</a></code>. </td></tr>
    <tr><td class="paramname">portConfig</td><td>A comma-separated sequence of port configurations. </td></tr>
    <tr><td class="paramname">readState</td><td>Pointer to a <code>uint32</code> to be set on exit to the port readback. </td></tr>
    <tr><td class="paramname">error</td><td>A pointer to a <code>const char*</code> which will be set on exit to an allocated error message if something goes wrong. Responsibility for this allocated memory passes to the caller and must be freed with <code><a class="el" href="libfpgalink_8h.html#a313f24c559a56d12518cb1e7eacdf01b" title="Free an error allocated when one of the other functions fails.">flFreeError()</a></code>. If <code>error</code> is <code>NULL</code>, no allocation is done and no message is returned, but the return code will still be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>FL_SUCCESS</code> if the port access command completed successfully.</li>
<li><code>FL_CONF_FORMAT</code> if <code>portConfig</code> is malformed.</li>
<li><code>FL_PORT_IO</code> if the micro failed to respond to the port access command. </li>
</ul>
</dd></dl>

</div>
</div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 17 2018 17:00:58 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>
<br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/>


</body>
</html>
